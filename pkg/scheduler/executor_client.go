package scheduler

import (
	"bytes"
	"fmt"
	"hash/crc64"
	"sort"
	"strconv"

	"github.com/gogo/protobuf/proto"

	execcfg "github.com/mesosphere/kubernetes-mesos/pkg/executor/config"
	"github.com/mesosphere/kubernetes-mesos/pkg/scheduler/uid"

	mesos "github.com/mesos/mesos-go/mesosproto"
	mutil "github.com/mesos/mesos-go/mesosutil"
)

type ExecutorClient struct {
	id uid.UID
	name string
    source string
	command *mesos.CommandInfo //TODO(karl) translate to business object?
	data []byte //TODO(karl) how is data populated? It's used by the hash func (defaults to nil)
}

func NewExecutorClient(command *mesos.CommandInfo) *ExecutorClient {
	e := &ExecutorClient{
		name: execcfg.DefaultInfoName,
		source: execcfg.DefaultInfoSource,
		command: command,
	}
	e.id = uid.New(hashCode(e), execcfg.DefaultInfoID)
	return e
}

func (e *ExecutorClient) ID() uid.UID {
	return e.id
}

func (e *ExecutorClient) Name() string {
	return e.name
}

func (e *ExecutorClient) Source() string {
	return e.source
}

func (e *ExecutorClient) Command() *mesos.CommandInfo {
	return e.command
}

func (e *ExecutorClient) Data() []byte {
	return e.data
}

func (e *ExecutorClient) ToProto() *mesos.ExecutorInfo {
	return &mesos.ExecutorInfo{
		ExecutorId: mutil.NewExecutorID(e.id.String()),
		Command: e.command,
		Name: proto.String(e.name),
		Source: proto.String(e.source),
		Data: e.data,
	}
}

// compute a hashcode for ExecutorRef that may be used as a reasonable litmus test
// with respect to compatibility across HA schedulers. the intent is that an HA scheduler
// should fail-fast if it doesn't pass this test, rather than generating (potentially many)
// errors at run-time because a Mesos master decides that the ExecutorInfo generated by a
// secondary scheduler doesn't match that of the primary scheduler.
//
// see https://github.com/apache/mesos/blob/0.22.0/src/common/type_utils.cpp#L110
func hashCode(info *ExecutorClient) uint64 {
	// !!! we specifically do NOT include:
	// - Framework ID because it's a value that's initialized too late for us to use
	// - Executor ID because it's a value that includes a copy of this hash
	buf := &bytes.Buffer{}
	buf.WriteString(info.name)
	buf.WriteString(info.source)
	buf.Write(info.data)

	cmd := info.command
	if cmd != nil {
		buf.WriteString(cmd.GetValue())
		buf.WriteString(cmd.GetUser())
		buf.WriteString(strconv.FormatBool(cmd.GetShell()))
		if sz := len(cmd.Arguments); sz > 0 {
			x := make([]string, sz)
			copy(x, cmd.Arguments)
			sort.Strings(x)
			for _, item := range x {
				buf.WriteString(item)
			}
		}
		if vars := cmd.Environment.GetVariables(); vars != nil && len(vars) > 0 {
			names := []string{}
			e := make(map[string]string)

			for _, v := range vars {
				if name := v.GetName(); name != "" {
					names = append(names, name)
					e[name] = v.GetValue()
				}
			}
			sort.Strings(names)
			for _, n := range names {
				buf.WriteString(n)
				buf.WriteString("=")
				buf.WriteString(e[n])
			}
		}
		if uris := cmd.GetUris(); len(uris) > 0 {
			su := []string{}
			for _, uri := range uris {
				su = append(su, fmt.Sprintf("%s%t%t", uri.GetValue(), uri.GetExecutable(), uri.GetExtract()))
			}
			sort.Strings(su)
			for _, uri := range su {
				buf.WriteString(uri)
			}
		}
		//TODO(jdef) add support for Resources and Container
	}
	table := crc64.MakeTable(crc64.ECMA)
	return crc64.Checksum(buf.Bytes(), table)
}
